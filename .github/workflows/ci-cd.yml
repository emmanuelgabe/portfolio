name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - staging
      - dev
      - 'dev/**'
  pull_request:
    branches:
      - main
      - staging
  workflow_dispatch:
    inputs:
      clean_messaging_volumes:
        description: 'Clean Kafka/Zookeeper volumes (use if cluster ID mismatch error)'
        type: boolean
        default: false

env:
  JAVA_VERSION: '21'
  JAVA_DISTRIBUTION: 'temurin'

jobs:
  build-and-test:
    runs-on: self-hosted
    outputs:
      version: ${{ steps.version.outputs.VERSION }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version from Git tags
        id: version
        run: |
          VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "0.0.1-SNAPSHOT")
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          cache: gradle

      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew
        working-directory: portfolio-backend

      - name: Build and Test Backend with Gradle
        run: ./gradlew clean build -Pversion=${{ steps.version.outputs.VERSION }}
        working-directory: portfolio-backend

      - name: Run Backend Code Quality Checks
        run: |
          echo "Running Checkstyle..."
          ./gradlew checkstyleMain checkstyleTest
          echo "Running SpotBugs..."
          ./gradlew spotbugsMain
          echo "Verifying code coverage (80% minimum)..."
          ./gradlew jacocoTestCoverageVerification
        working-directory: portfolio-backend

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: portfolio-frontend/package-lock.json

      - name: Install Frontend Dependencies
        run: npm ci
        working-directory: portfolio-frontend

      - name: Lint Frontend
        run: npm run lint
        working-directory: portfolio-frontend

      - name: Build Frontend
        run: npm run build -- --configuration=production
        working-directory: portfolio-frontend

      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: portfolio-backend/build/reports/tests/test/
          retention-days: 30

      - name: Upload Coverage Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: portfolio-backend/build/reports/jacoco/test/html/
          retention-days: 30

  deploy:
    runs-on: self-hosted
    needs: build-and-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging'
    environment:
      name: ${{ github.ref_name == 'main' && 'production' || 'staging' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set deployment variables
        id: deploy-vars
        run: |
          DEPLOY_BASE="${{ secrets.DEPLOY_BASE_PATH }}"
          if [ -z "$DEPLOY_BASE" ]; then
            echo "[ERROR] DEPLOY_BASE_PATH secret is not configured"
            exit 1
          fi

          if [ "$GITHUB_REF_NAME" == "main" ]; then
            echo "ENV_NAME=prod" >> $GITHUB_OUTPUT
            echo "COMPOSE_FILE=docker-compose.prod.yml" >> $GITHUB_OUTPUT
            echo "DEPLOY_PATH=$DEPLOY_BASE/prod" >> $GITHUB_OUTPUT
          else
            echo "ENV_NAME=staging" >> $GITHUB_OUTPUT
            echo "COMPOSE_FILE=docker-compose.staging.yml" >> $GITHUB_OUTPUT
            echo "DEPLOY_PATH=$DEPLOY_BASE/staging" >> $GITHUB_OUTPUT
          fi

      - name: Backup database before deployment
        if: github.ref_name == 'main'
        run: |
          ENV_NAME="${{ steps.deploy-vars.outputs.ENV_NAME }}"
          BACKUP_DIR="${{ secrets.DEPLOY_BASE_PATH }}/backups"
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          BACKUP_FILE="portfolio_${ENV_NAME}_${TIMESTAMP}.sql"

          echo "========================================="
          echo "Database Backup - $ENV_NAME"
          echo "========================================="

          # Check if database container is running
          if docker ps --filter "name=portfolio-db-$ENV_NAME" --filter "status=running" | grep -q portfolio-db; then
            echo "Creating backup directory: $BACKUP_DIR"
            mkdir -p "$BACKUP_DIR"

            echo "Creating database backup: $BACKUP_FILE"
            DB_NAME="portfolio_${ENV_NAME}"
            docker exec portfolio-db-$ENV_NAME pg_dump -U postgres_app "$DB_NAME" > "$BACKUP_DIR/$BACKUP_FILE"

            if [ -f "$BACKUP_DIR/$BACKUP_FILE" ] && [ -s "$BACKUP_DIR/$BACKUP_FILE" ]; then
              echo "[SUCCESS] Backup created: $BACKUP_DIR/$BACKUP_FILE"
              ls -lh "$BACKUP_DIR/$BACKUP_FILE"

              # Keep only last 5 backups
              echo "Cleaning old backups (keeping last 5)..."
              ls -t "$BACKUP_DIR"/portfolio_${ENV_NAME}_*.sql 2>/dev/null | tail -n +6 | xargs -r rm -f
              echo "Current backups:"
              ls -lt "$BACKUP_DIR"/portfolio_${ENV_NAME}_*.sql 2>/dev/null | head -5
            else
              echo "[WARNING] Backup file is empty or was not created"
            fi
          else
            echo "[INFO] No running database container found, skipping backup"
          fi

      - name: Stop existing deployment
        run: |
          ENV_NAME="${{ steps.deploy-vars.outputs.ENV_NAME }}"
          COMPOSE_FILE="${{ steps.deploy-vars.outputs.COMPOSE_FILE }}"
          DEPLOY_PATH="${{ steps.deploy-vars.outputs.DEPLOY_PATH }}"

          echo "========================================="
          echo "Stopping existing $ENV_NAME deployment"
          echo "========================================="

          # If deployment exists, stop it properly with docker-compose down
          if [ -d "$DEPLOY_PATH" ]; then
            echo "Found existing deployment at $DEPLOY_PATH"
            cd "$DEPLOY_PATH"

            if [ -f "docker-compose.yml" ] && [ -f "$COMPOSE_FILE" ]; then
              echo "Bringing down Docker Compose stack (timeout: 30s)..."
              docker compose --env-file /dev/null -p portfolio-$ENV_NAME -f docker-compose.yml -f "$COMPOSE_FILE" down --timeout 30 2>&1 || echo "Stack not running or already stopped"
            else
              echo "Docker Compose files not found, skipping docker-compose down"
            fi
            cd -
          else
            echo "No existing deployment found at $DEPLOY_PATH"
          fi

          # Force stop any remaining containers for this environment
          echo ""
          echo "[CLEANUP] Checking for remaining $ENV_NAME containers..."
          REMAINING=$(docker ps -a --filter "name=portfolio.*-$ENV_NAME" --format "{{.Names}}")

          if [ -n "$REMAINING" ]; then
            echo "[CLEANUP] Found remaining containers:"
            echo "$REMAINING"
            echo "[CLEANUP] Force stopping and removing..."
            echo "$REMAINING" | xargs -r docker stop || true
            echo "$REMAINING" | xargs -r docker rm -f || true
          else
            echo "[CLEANUP] No remaining containers found"
          fi

          # Cleanup Kafka volume if requested (KRaft mode - no Zookeeper)
          if [ "${{ github.event.inputs.clean_messaging_volumes }}" = "true" ]; then
            echo ""
            echo "[CLEANUP] Cleaning Kafka volume (requested via workflow input)..."
            docker volume rm -f "portfolio-${ENV_NAME}_portfolio_kafka_data" 2>/dev/null && echo "[CLEANUP] Removed Kafka volume" || echo "[CLEANUP] Kafka volume not found"
          fi

          # Cleanup zombie docker-proxy processes holding environment-specific ports
          echo ""
          echo "[CLEANUP] Checking for zombie docker-proxy processes..."

          # Define ports per environment (including monitoring ports)
          if [ "$ENV_NAME" = "staging" ]; then
            PORTS_TO_CHECK="3000 6380 15673 9090 9093 3001"  # Nginx, Redis, RabbitMQ, Prometheus, AlertManager, Grafana
          elif [ "$ENV_NAME" = "prod" ]; then
            PORTS_TO_CHECK="80 9090 9093 3001"  # Nginx, Prometheus, AlertManager, Grafana
          else
            PORTS_TO_CHECK=""
          fi

          for PORT in $PORTS_TO_CHECK; do
            # Use exact port match to avoid false positives (e.g., :80 vs :8080)
            if ss -tlnp 2>/dev/null | grep -qE ":${PORT}\s"; then
              echo "[CLEANUP] Port $PORT still in use, checking for docker-proxy..."
              # Portable PID extraction using awk instead of grep -oP
              PROXY_PID=$(ss -tlnp 2>/dev/null | grep -E ":${PORT}\s" | awk -F'pid=' '{print $2}' | awk -F',' '{print $1}' | head -1)
              if [ -n "$PROXY_PID" ]; then
                PROC_NAME=$(ps -p "$PROXY_PID" -o comm= 2>/dev/null || echo "unknown")
                if [ "$PROC_NAME" = "docker-proxy" ]; then
                  echo "[CLEANUP] Killing zombie docker-proxy - pid=$PROXY_PID, port=$PORT"
                  # Try graceful SIGTERM first, then force SIGKILL if needed
                  sudo kill -15 "$PROXY_PID" 2>/dev/null || true
                  sleep 1
                  if ps -p "$PROXY_PID" > /dev/null 2>&1; then
                    echo "[CLEANUP] Process still alive, forcing SIGKILL - pid=$PROXY_PID"
                    sudo kill -9 "$PROXY_PID" 2>/dev/null || true
                  fi
                else
                  echo "[CLEANUP] Port $PORT used by $PROC_NAME (pid=$PROXY_PID), not a docker-proxy - skipping"
                fi
              fi
            else
              echo "[CLEANUP] Port $PORT is free"
            fi
          done

          # CRITICAL: Verify port 80 availability for production deployments
          if [ "$ENV_NAME" = "prod" ]; then
            echo ""
            echo "========================================="
            echo "Verifying port 80 availability"
            echo "========================================="

            # Check if port 80 is in use (using ss instead of lsof - more reliable)
            PORT_IN_USE=$(ss -tlnp 2>/dev/null | grep -q ':80 ' && echo "yes" || echo "no")

            if [ "$PORT_IN_USE" = "yes" ]; then
              echo "[WARNING] Port 80 is already in use!"
              echo "Processes using port 80:"
              ss -tlnp | grep ':80 ' || true

              # Check Docker containers on port 80
              echo ""
              echo "Checking Docker containers with port 80 bindings..."
              docker ps -a --filter "publish=80" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

              # Stop portfolio containers on port 80
              echo ""
              echo "Stopping any portfolio containers using port 80..."
              CONTAINERS_ON_PORT_80=$(docker ps -a --filter "publish=80" --filter "name=portfolio" --format "{{.Names}}")

              if [ -n "$CONTAINERS_ON_PORT_80" ]; then
                echo "Found: $CONTAINERS_ON_PORT_80"
                echo "$CONTAINERS_ON_PORT_80" | xargs -r docker stop || true
                echo "$CONTAINERS_ON_PORT_80" | xargs -r docker rm || true
                sleep 2

                # Verify port is now free
                if ss -tlnp 2>/dev/null | grep -q ':80 '; then
                  echo "[WARNING] Port 80 still in use, but continuing anyway..."
                else
                  echo "[SUCCESS] Port 80 is now available"
                fi
              else
                echo "[WARNING] Port 80 in use by non-portfolio process, continuing anyway..."
              fi
            else
              echo "[SUCCESS] Port 80 is available"
            fi
          fi

          echo ""
          echo "Cleanup completed!"

          # Stop monitoring stack if running
          echo ""
          echo "========================================="
          echo "Checking monitoring stack"
          echo "========================================="
          MONITORING_CONTAINERS=$(docker ps --filter "name=portfolio-prometheus-prod" --filter "name=portfolio-loki-prod" --filter "name=portfolio-promtail-prod" --filter "name=portfolio-grafana-prod" --filter "name=portfolio-alertmanager-prod" --filter "name=portfolio-kafka-exporter-prod" --format "{{.Names}}" 2>/dev/null || true)
          if [ -n "$MONITORING_CONTAINERS" ]; then
            echo "Stopping monitoring stack containers..."
            echo "$MONITORING_CONTAINERS" | xargs -r docker stop || true
            echo "$MONITORING_CONTAINERS" | xargs -r docker rm || true
            echo "Monitoring stack stopped"
          else
            echo "No monitoring stack running"
          fi

      - name: Clean and prepare deployment directory
        run: |
          DEPLOY_PATH="${{ steps.deploy-vars.outputs.DEPLOY_PATH }}"

          echo "Preparing deployment directory: $DEPLOY_PATH"

          # Remove old deployment directory
          rm -rf "$DEPLOY_PATH"

          # Create fresh deployment directory
          mkdir -p "$DEPLOY_PATH"

          echo "Deployment directory ready"

      - name: Copy artifacts to deployment folder
        run: |
          DEPLOY_PATH="${{ steps.deploy-vars.outputs.DEPLOY_PATH }}"

          echo "Copying files to $DEPLOY_PATH..."

          # Copy .git for version generation (required for frontend)
          cp -r .git "$DEPLOY_PATH/"

          # Copy source files
          cp -r portfolio-backend "$DEPLOY_PATH/"
          cp -r portfolio-frontend "$DEPLOY_PATH/"
          cp -r nginx "$DEPLOY_PATH/"

          # Copy Docker Compose files
          cp docker-compose.yml "$DEPLOY_PATH/"
          cp ${{ steps.deploy-vars.outputs.COMPOSE_FILE }} "$DEPLOY_PATH/"

          # Copy monitoring stack
          cp docker-compose.monitoring.yml "$DEPLOY_PATH/"
          cp -r monitoring "$DEPLOY_PATH/"

          echo "Files copied successfully"

      - name: Cleanup dangling images
        run: |
          echo "Cleaning up dangling images..."
          docker image prune -f

      - name: Reset Docker networking
        run: |
          echo "Cleaning up Docker networks..."
          docker network prune -f

          echo "Removing any portfolio networks that might be stale..."
          docker network ls --filter "name=portfolio" -q | xargs -r docker network rm 2>/dev/null || true

          echo "Verifying Docker is operational..."
          docker info > /dev/null 2>&1 && echo "[SUCCESS] Docker is ready" || echo "[ERROR] Docker not ready"

      - name: Create environment file
        working-directory: ${{ steps.deploy-vars.outputs.DEPLOY_PATH }}
        run: |
          ENV_NAME="${{ steps.deploy-vars.outputs.ENV_NAME }}"

          echo "Creating .env file for $ENV_NAME environment..."

          # Create .env file with secrets (more secure than command line arguments)
          # Using single quotes to prevent shell expansion of $ in BCrypt hash
          echo 'DB_USER_PASSWORD=${{ secrets.DB_USER_PASSWORD }}' > .env
          echo 'REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}' >> .env
          echo 'MAIL_USERNAME=${{ secrets.MAIL_USERNAME }}' >> .env
          echo 'MAIL_APP_PASSWORD=${{ secrets.MAIL_APP_PASSWORD }}' >> .env
          echo 'JWT_SECRET=${{ secrets.JWT_SECRET }}' >> .env
          echo 'ADMIN_PASSWORD_HASH=${{ secrets.ADMIN_PASSWORD_HASH }}' >> .env
          echo 'VERSION=${{ needs.build-and-test.outputs.version }}' >> .env

          # RabbitMQ
          echo 'RABBITMQ_USERNAME=${{ secrets.RABBITMQ_USERNAME }}' >> .env
          echo 'RABBITMQ_PASSWORD=${{ secrets.RABBITMQ_PASSWORD }}' >> .env

          # Elasticsearch
          echo 'ELASTICSEARCH_PASSWORD=${{ secrets.ELASTICSEARCH_PASSWORD }}' >> .env

          # Observability stack (Sentry + Grafana)
          echo 'SENTRY_DSN=${{ secrets.SENTRY_DSN }}' >> .env
          echo 'SENTRY_DSN_FRONTEND=${{ secrets.SENTRY_DSN_FRONTEND }}' >> .env
          echo 'GRAFANA_ADMIN_USER=admin' >> .env
          echo 'GRAFANA_ADMIN_PASSWORD=${{ secrets.GRAFANA_ADMIN_PASSWORD }}' >> .env

          # Restrict permissions on .env file
          chmod 600 .env

          echo "Environment file created with restricted permissions"

      - name: Deploy with Docker Compose
        working-directory: ${{ steps.deploy-vars.outputs.DEPLOY_PATH }}
        run: |
          COMPOSE_FILE="${{ steps.deploy-vars.outputs.COMPOSE_FILE }}"
          ENV_NAME="${{ steps.deploy-vars.outputs.ENV_NAME }}"
          VERSION="${{ needs.build-and-test.outputs.version }}"

          echo "========================================="
          echo "Deploying $ENV_NAME environment"
          echo "Version: $VERSION"
          echo "========================================="

          # Verify compose files exist
          echo "Verifying Docker Compose files..."
          ls -la docker-compose.yml "$COMPOSE_FILE"

          echo ""
          echo "Building and starting containers..."
          # Use --env-file to load secrets securely (avoids exposing in ps/logs)
          docker compose --env-file .env -p portfolio-$ENV_NAME -f docker-compose.yml -f "$COMPOSE_FILE" up --build -d --remove-orphans

          echo ""
          echo "Containers started, waiting for health checks..."

      - name: Cleanup environment file
        if: always()
        working-directory: ${{ steps.deploy-vars.outputs.DEPLOY_PATH }}
        run: |
          # Remove .env file after deployment to avoid secrets persisting on disk
          if [ -f .env ]; then
            rm -f .env
            echo "Environment file cleaned up"
          fi

      - name: Wait for containers to be healthy
        working-directory: ${{ steps.deploy-vars.outputs.DEPLOY_PATH }}
        run: |
          ENV_NAME="${{ steps.deploy-vars.outputs.ENV_NAME }}"
          MAX_ATTEMPTS=120  # 10 minutes (120 * 5s sleep)
          ATTEMPT=0

          echo "Waiting for all containers to reach healthy status..."

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))

            # Check if containers exist and are running
            DB_EXISTS=$(docker ps -q --filter "name=portfolio-db-$ENV_NAME" 2>/dev/null)
            BACKEND_EXISTS=$(docker ps -q --filter "name=portfolio-backend-$ENV_NAME" 2>/dev/null)
            FRONTEND_EXISTS=$(docker ps -q --filter "name=portfolio-frontend-$ENV_NAME" 2>/dev/null)
            NGINX_EXISTS=$(docker ps -q --filter "name=portfolio-nginx-$ENV_NAME" 2>/dev/null)

            # Check health status (only for containers with healthcheck)
            if [ -n "$DB_EXISTS" ]; then
              DB_HEALTH=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}running{{end}}' portfolio-db-$ENV_NAME 2>/dev/null)
            else
              DB_HEALTH="not_running"
            fi

            if [ -n "$BACKEND_EXISTS" ]; then
              BACKEND_HEALTH=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}running{{end}}' portfolio-backend-$ENV_NAME 2>/dev/null)
            else
              BACKEND_HEALTH="not_running"
            fi

            if [ -n "$FRONTEND_EXISTS" ]; then
              FRONTEND_HEALTH=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}running{{end}}' portfolio-frontend-$ENV_NAME 2>/dev/null)
            else
              FRONTEND_HEALTH="not_running"
            fi

            if [ -n "$NGINX_EXISTS" ]; then
              NGINX_HEALTH="running"
            else
              NGINX_HEALTH="not_running"
            fi

            echo "[$ATTEMPT/$MAX_ATTEMPTS] DB: $DB_HEALTH | Backend: $BACKEND_HEALTH | Frontend: $FRONTEND_HEALTH | Nginx: $NGINX_HEALTH"

            # Check if all are healthy or running
            if [ "$DB_HEALTH" = "healthy" ] && [ "$BACKEND_HEALTH" = "healthy" ] && [ "$FRONTEND_HEALTH" = "healthy" ] && [ "$NGINX_HEALTH" = "running" ]; then
              echo "[SUCCESS] All containers are healthy!"
              exit 0
            fi

            # Check for unhealthy or not running containers
            if [ "$DB_HEALTH" = "unhealthy" ] || [ "$BACKEND_HEALTH" = "unhealthy" ] || [ "$FRONTEND_HEALTH" = "unhealthy" ]; then
              echo "[ERROR] One or more containers are unhealthy!"
              echo "Showing container logs..."
              [ "$DB_HEALTH" = "unhealthy" ] && docker logs --tail=50 portfolio-db-$ENV_NAME
              [ "$BACKEND_HEALTH" = "unhealthy" ] && docker logs --tail=50 portfolio-backend-$ENV_NAME
              [ "$FRONTEND_HEALTH" = "unhealthy" ] && docker logs --tail=50 portfolio-frontend-$ENV_NAME
              exit 1
            fi

            if [ "$DB_HEALTH" = "not_running" ] || [ "$BACKEND_HEALTH" = "not_running" ] || [ "$FRONTEND_HEALTH" = "not_running" ] || [ "$NGINX_HEALTH" = "not_running" ]; then
              echo "[WARN] Some containers are not running yet, waiting..."
              docker ps -a --filter "name=portfolio.*-$ENV_NAME"
            fi

            sleep 5
          done

          echo "[ERROR] Timeout waiting for containers to be healthy"
          echo "Final status - DB: $DB_HEALTH | Backend: $BACKEND_HEALTH | Frontend: $FRONTEND_HEALTH | Nginx: $NGINX_HEALTH"
          echo ""
          echo "Container status:"
          docker ps -a --filter "name=portfolio.*-$ENV_NAME"
          echo ""
          echo "Container logs:"
          docker logs --tail=50 portfolio-db-$ENV_NAME 2>&1 || true
          docker logs --tail=50 portfolio-backend-$ENV_NAME 2>&1 || true
          docker logs --tail=50 portfolio-frontend-$ENV_NAME 2>&1 || true
          docker logs --tail=50 portfolio-nginx-$ENV_NAME 2>&1 || true
          exit 1

      - name: Deploy monitoring stack
        if: github.ref_name == 'main'
        working-directory: ${{ steps.deploy-vars.outputs.DEPLOY_PATH }}
        run: |
          ENV_NAME="${{ steps.deploy-vars.outputs.ENV_NAME }}"

          echo "========================================="
          echo "Deploying monitoring stack"
          echo "========================================="

          # Check if monitoring compose file exists
          if [ ! -f "docker-compose.monitoring.yml" ]; then
            echo "[WARNING] docker-compose.monitoring.yml not found, skipping monitoring deployment"
            exit 0
          fi

          # Check if Grafana password is configured
          GRAFANA_PASS="${{ secrets.GRAFANA_ADMIN_PASSWORD }}"
          if [ -z "$GRAFANA_PASS" ]; then
            echo "[WARNING] GRAFANA_ADMIN_PASSWORD not configured, skipping monitoring deployment"
            exit 0
          fi

          # Create temporary .env for monitoring stack
          # NETWORK_NAME must match the network created by the main stack (portfolio-{ENV_NAME}_portfolio-net)
          echo "NETWORK_NAME=portfolio-${ENV_NAME}_portfolio-net" > .env.monitoring
          echo 'GRAFANA_ADMIN_USER=admin' >> .env.monitoring
          echo 'GRAFANA_ADMIN_PASSWORD=${{ secrets.GRAFANA_ADMIN_PASSWORD }}' >> .env.monitoring
          chmod 600 .env.monitoring

          echo "[MONITORING] Using network: portfolio-${ENV_NAME}_portfolio-net"

          # Deploy monitoring stack
          echo "[MONITORING] Starting Prometheus, Loki, Promtail, and Grafana..."
          docker compose --env-file .env.monitoring -p portfolio-monitoring -f docker-compose.monitoring.yml up -d --remove-orphans

          # Cleanup temporary env file
          rm -f .env.monitoring

          echo ""
          echo "Monitoring stack containers:"
          docker ps --filter "name=portfolio-prometheus-prod" --filter "name=portfolio-loki-prod" --filter "name=portfolio-promtail-prod" --filter "name=portfolio-grafana-prod" --filter "name=portfolio-alertmanager-prod" --filter "name=portfolio-kafka-exporter-prod" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

          echo ""
          echo "[MONITORING] Stack deployed successfully"
          echo "[MONITORING] Grafana available at: http://localhost:3001"

      - name: Tag Docker images with version
        run: |
          VERSION=${{ needs.build-and-test.outputs.version }}
          ENV_NAME="${{ steps.deploy-vars.outputs.ENV_NAME }}"

          echo "Tagging images with version: $VERSION"

          # Tag backend image
          BACKEND_IMAGE=$(docker ps --filter "name=portfolio-backend-$ENV_NAME" --format "{{.Image}}")
          if [ -n "$BACKEND_IMAGE" ]; then
            docker tag "$BACKEND_IMAGE" "portfolio-backend:$VERSION"
            docker tag "$BACKEND_IMAGE" "portfolio-backend:latest"
            docker tag "$BACKEND_IMAGE" "portfolio-backend:$ENV_NAME-latest"
            echo "Tagged backend: portfolio-backend:$VERSION"
          fi

          # Tag frontend image
          FRONTEND_IMAGE=$(docker ps --filter "name=portfolio-frontend-$ENV_NAME" --format "{{.Image}}")
          if [ -n "$FRONTEND_IMAGE" ]; then
            docker tag "$FRONTEND_IMAGE" "portfolio-frontend:$VERSION"
            docker tag "$FRONTEND_IMAGE" "portfolio-frontend:latest"
            docker tag "$FRONTEND_IMAGE" "portfolio-frontend:$ENV_NAME-latest"
            echo "Tagged frontend: portfolio-frontend:$VERSION"
          fi

      - name: Smoke tests
        run: |
          ENV_NAME="${{ steps.deploy-vars.outputs.ENV_NAME }}"

          # Determine the port based on environment
          if [ "$ENV_NAME" = "prod" ]; then
            PORT=80
          else
            PORT=3000
          fi

          echo "Running smoke tests on port $PORT..."

          # Test 1: Frontend health endpoint
          echo "Testing frontend health endpoint..."
          FRONTEND_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:$PORT/health.json || echo "000")
          if [ "$FRONTEND_HEALTH" = "200" ]; then
            echo "[SUCCESS] Frontend health check passed"
          else
            echo "[ERROR] Frontend health check failed (HTTP $FRONTEND_HEALTH)"
            exit 1
          fi

          # Test 2: Backend actuator health endpoint
          echo "Testing backend actuator health endpoint..."
          if docker exec portfolio-backend-$ENV_NAME wget --quiet --spider http://localhost:8080/actuator/health >/dev/null 2>&1; then
            echo "[SUCCESS] Backend actuator health check passed"
          else
            echo "[ERROR] Backend actuator health check failed"
            exit 1
          fi

          # Test 3: Database connectivity
          echo "Testing database connectivity..."
          if [ "$ENV_NAME" = "prod" ]; then
            DB_NAME="portfolio_prod"
          else
            DB_NAME="portfolio_staging"
          fi
          DB_TEST=$(docker exec portfolio-db-$ENV_NAME psql -U postgres_app -d $DB_NAME -c "SELECT 1;" 2>&1)
          if echo "$DB_TEST" | grep -q "1 row"; then
            echo "[SUCCESS] Database connectivity test passed"
          else
            echo "[ERROR] Database connectivity test failed"
            echo "$DB_TEST"
            exit 1
          fi

          # Test 4: Full stack integration (nginx -> frontend)
          echo "Testing full stack integration..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:$PORT/ || echo "000")
          if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "304" ]; then
            echo "[SUCCESS] Full stack integration test passed (HTTP $HTTP_STATUS)"
          else
            echo "[ERROR] Full stack integration test failed (HTTP $HTTP_STATUS)"
            exit 1
          fi

          echo ""
          echo "========================================="
          echo "[SUCCESS] All smoke tests passed!"
          echo "========================================="

      - name: Cleanup old images
        run: |
          echo "Cleaning up dangling images..."
          docker image prune -f

          echo "Removing unused portfolio volumes..."
          docker volume ls --filter "name=portfolio" -q | xargs -r docker volume rm 2>/dev/null || true

      - name: Verify deployment
        run: |
          ENV_NAME="${{ steps.deploy-vars.outputs.ENV_NAME }}"

          echo "=== Running containers ==="
          docker ps --filter "name=portfolio.*-$ENV_NAME"

          echo ""
          echo "=== Container health status ==="
          docker ps --filter "name=portfolio.*-$ENV_NAME" --format "table {{.Names}}\t{{.Status}}"

          echo ""
          echo "=== Disk usage ==="
          docker system df

      - name: Deployment summary
        if: always()
        run: |
          ENV_NAME="${{ steps.deploy-vars.outputs.ENV_NAME }}"
          VERSION="${{ needs.build-and-test.outputs.version }}"

          echo "========================================="
          echo "Deployment Summary"
          echo "========================================="
          echo "Environment: $ENV_NAME"
          echo "Version: $VERSION"
          echo "Branch: $GITHUB_REF_NAME"
          echo "Commit: $GITHUB_SHA"
          echo ""
          echo "Observability:"
          echo "  - Sentry: Enabled (backend + frontend)"
          echo "  - Prometheus: http://localhost:9090"
          echo "  - Grafana: http://localhost:3001"
          echo "  - Loki: http://localhost:3100"
          echo "========================================="
